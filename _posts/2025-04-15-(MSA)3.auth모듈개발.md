---
layout: post
title: (MSA)3.auth 모듈개발
category: [Auth]
tags: [Auth, Spring Security, JWT]
redirect_from:

- /2025/04/15/

---
# Spring Boot JWT 인증 서버 구성하기 (Hexagonal Architecture + MySQL)

이번 글에서는 `Spring Boot` 기반으로 **JWT 인증 서버를 구축하는 방법**을 정리합니다.  
아키텍처는 **헥사고날 아키텍처(Hexagonal Architecture)** 패턴을 따르며, DB는 `MySQL`, 빌드 도구는 `Gradle`을 사용합니다.
이 구조는 확장성과 테스트 편의성이 뛰어나며, 도메인 → 유스케이스 → 어댑터로 흐름이 깔끔하게 나뉘어 유지보수가 매우 좋습니다.

---

## 📦 패키지 구조

```bash
com.enjoywalk.auth
│
├── application                  # 유스케이스 계층
│   ├── port
│   │   ├── in                   # 유스케이스 입력 (ex. 로그인 요청)
│   │   └── out                  # 유스케이스 출력 (ex. 유저 조회, 토큰 저장)
│   └── service                  # 유스케이스 구현
│
├── domain                       # 도메인 계층
│   ├── model                    # 순수 도메인 객체 (User, Token 등)
│   └── service                  # 도메인 규칙/정책 처리
│
├── adapter
│   ├── in
│   │   └── web                  # REST 컨트롤러 (Spring MVC)
│   └── out
│       ├── persistence          # JPA Repository 및 DB 어댑터
│       └── external             # 외부 시스템 (ex. 이메일, OAuth2 provider 등)
│
├── config                       # 보안, JPA, CORS 등 설정
│   ├── JwtConfig.java
│   └── SecurityConfig.java
│
└── AuthApplication.java         # 메인 클래스
```

⚙️ Gradle 설정 (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot'
    id 'io.spring.dependency-management'
}

dependencies {
    implementation project(':common') // common 모듈 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5' // JSON 처리용
}
```

🛠️ application.yml 설정
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/authdb?useSSL=false&serverTimezone=UTC
    username: your_db_user
    password: your_db_password
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
    database-platform: org.hibernate.dialect.MySQL8Dialect

  servlet:
    multipart:
      enabled: true

server:
  port: 8080

jwt:
  secret: your-256-bit-secret
  expiration: 3600000 # 1 hour
```

✅ logback-spring.xml 설정 예시
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <!-- 콘솔 출력용 패턴 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>

    <!-- 로그 파일 경로 -->
    <property name="LOG_PATH" value="logs"/>

    <!-- 콘솔 출력 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 파일 출력 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/application.log</file>

        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>14</maxHistory>
        </rollingPolicy>

        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- Hibernate SQL 로그용 별도 설정 (SQL은 많이 나오니 info로 필터링) -->
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>

    <!-- Spring / Application 로그 레벨 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

</configuration>
```

🔐 JwtConfig 클래스 (JWT 설정 바인딩)
```java
@Configuration
@ConfigurationProperties(prefix = "jwt")
public class JwtConfig {
    private String secret;
    private long expiration;

    // Getters and Setters
}
```

🔐 Spring Security 설정 (SecurityConfig)
```java
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtTokenFilter jwtTokenFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

🔁 구성 흐름 요약
```text
[Request] 
   → Adapter In (Web: Controller)
      → Application Port In (UseCase Interface)
         → Application Service (유스케이스 구현체)
            → Domain Model / Domain Service
            → Application Port Out (Repository Interface)
               → Adapter Out (JPA, 외부 API 등)

```

